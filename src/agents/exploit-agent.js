import { BaseAgent } from './base-agent.js';
import fs from 'fs';

/**
 * Exploit Agent for Billy LLM Multi-Agent System
 * Specializes in exploit development and vulnerability testing
 * Created by BillyC0der
 */
export class ExploitAgent extends BaseAgent {
  constructor(llmClient) {
    super('ExploitAgent', llmClient);
    this.capabilities = ['exploit', 'attack', 'payload', 'test', 'validate'];
    this.exploitTypes = ['sqli', 'xss', 'rce', 'lfi', 'rfi', 'csrf', 'xxe', 'ssrf', 'buffer', 'privesc'];
    this.payloadTypes = ['revshell', 'webshell', 'bindshell', 'meterpreter', 'powershell'];
  }

  async performTask(task) {
    this.logger.info(`Performing exploit task: ${task.action}`);
    
    switch (task.action) {
      case 'exploit':
        return await this.generateExploit(task);
      case 'payload':
        return await this.generatePayload(task);
      case 'attack':
        return await this.planAttack(task);
      case 'test':
        return await this.testVulnerability(task);
      case 'validate':
        return await this.validateExploit(task);
      default:
        return await this.performGenericExploit(task); 
    }
  }

  async generateExploit(task) {
    const exploitType = task.parameters.type || task.parameters.vulnerability;
    const target = task.parameters.target;
    
    if (!exploitType) {
      throw new Error('Exploit type or vulnerability is required');
    }

    this.logger.info(`Generating ${exploitType} exploit for target: ${target || 'general'}`);

    // Determine schema based on exploit type
    let schema = null;
    try {
      const schemaPath = './schemas/exploit.json';
      if (fs.existsSync(schemaPath)) {
        schema = JSON.parse(fs.readFileSync(schemaPath, 'utf8'));
      }
    } catch (error) {
      this.logger.warning('Could not load exploit schema');
    }

    const exploitPrompt = `Generate a comprehensive ${exploitType} exploit for ${target || 'the target'}.
    
    Include:
    1. Exploit description and vulnerability details
    2. Complete exploit code with comments
    3. Usage instructions and requirements
    4. Risk assessment and impact
    5. Mitigation recommendations
    6. References and CVE information if applicable
    
    Exploit Type: ${exploitType}
    Target: ${target || 'General target'}
    
    Make the exploit production-ready with proper error handling.`;

    const exploitResult = await this.client.invoke(exploitPrompt, schema, true);

    // Enhanced exploit result with metadata
    const enhancedResult = {
      exploitType,
      target: target || 'general',
      exploit: exploitResult,
      metadata: {
        generated: new Date().toISOString(),
        agent: this.name,
        task: task.name,
        riskLevel: this.assessRiskLevel(exploitType),
        category: this.categorizeExploit(exploitType)
      }
    };

    // Save exploit to file
    const filename = `exploit-${exploitType}-${Date.now()}.json`;
    const filepath = `./results/${filename}`;
    
    try {
      fs.writeFileSync(filepath, JSON.stringify(enhancedResult, null, 2));
      enhancedResult.outputFile = filepath;
      this.logger.success(`Exploit saved to: ${filepath}`);
    } catch (error) {
      this.logger.warning(`Could not save exploit: ${error.message}`);
    }

    return enhancedResult;
  }

  async generatePayload(task) {
    const payloadType = task.parameters.type;
    const target = task.parameters.target;
    const ip = task.parameters.ip || '10.10.10.100';
    const port = task.parameters.port || '4444';

    if (!payloadType) {
      throw new Error('Payload type is required');
    }

    this.logger.info(`Generating ${payloadType} payload for ${ip}:${port}`);

    // Use payload schema if available
    let schema = null;
    try {
      const schemaPath = './schemas/payload.json';
      if (fs.existsSync(schemaPath)) {
        schema = JSON.parse(fs.readFileSync(schemaPath, 'utf8'));
      }
    } catch (error) {
      this.logger.warning('Could not load payload schema');
    }

    const payloadPrompt = `Generate ${payloadType} payload with the following specifications:
    
    Type: ${payloadType}
    Target IP: ${ip}
    Target Port: ${port}
    Target System: ${target || 'Linux/Windows compatible'}
    
    Generate multiple variants including:
    1. Basic payload
    2. Encoded/obfuscated version
    3. Language-specific implementations (bash, python, php, powershell)
    4. Usage instructions and setup
    5. Detection evasion techniques
    
    Make payloads production-ready with error handling and stealth features.`;

    const payloadResult = await this.client.invoke(payloadPrompt, schema, true);

    const enhancedResult = {
      payloadType,
      target: target || 'multi-platform',
      ip,
      port,
      payload: payloadResult,
      metadata: {
        generated: new Date().toISOString(),
        agent: this.name,
        task: task.name,
        stealth: true,
        multiplatform: true
      }
    };

    // Save payload to file
    const filename = `payload-${payloadType}-${Date.now()}.json`;
    const filepath = `./results/${filename}`;
    
    try {
      fs.writeFileSync(filepath, JSON.stringify(enhancedResult, null, 2));
      enhancedResult.outputFile = filepath;
      this.logger.success(`Payload saved to: ${filepath}`);
    } catch (error) {
      this.logger.warning(`Could not save payload: ${error.message}`);
    }

    return enhancedResult;
  }

  async planAttack(task) {
    const target = task.parameters.target;
    const vulnerabilities = task.parameters.vulnerabilities || task.parameters.vulns;
    
    this.logger.info(`Planning attack on target: ${target}`);

    const attackPrompt = `Create a comprehensive attack plan for target: ${target}.
    
    ${vulnerabilities ? `Known Vulnerabilities: ${vulnerabilities}` : ''}
    
    Generate:
    1. Attack timeline and phases
    2. Exploitation sequence
    3. Required tools and payloads
    4. Persistence mechanisms
    5. Privilege escalation paths
    6. Data exfiltration methods
    7. Cleanup and stealth considerations
    
    Make the plan detailed and executable.`;

    const attackPlan = await this.client.invoke(attackPrompt, null, true);

    return {
      target,
      vulnerabilities,
      attackPlan,
      metadata: {
        generated: new Date().toISOString(),
        agent: this.name,
        task: task.name
      }
    };
  }

  async testVulnerability(task) {
    const vulnerability = task.parameters.vulnerability || task.parameters.vuln;
    const target = task.parameters.target;
    
    this.logger.info(`Testing vulnerability: ${vulnerability} on ${target}`);

    const testPrompt = `Generate vulnerability testing procedures for:
    
    Vulnerability: ${vulnerability}
    Target: ${target}
    
    Include:
    1. Testing methodology
    2. Proof-of-concept code
    3. Expected results
    4. Impact assessment
    5. Remediation verification
    6. Reporting format
    
    Focus on safe, controlled testing procedures.`;

    const testResult = await this.client.invoke(testPrompt, null, true);

    return {
      vulnerability,
      target,
      test: testResult,
      timestamp: new Date().toISOString()
    };
  }

  async validateExploit(task) {
    const exploitCode = task.parameters.code || task.code;
    const exploitType = task.parameters.type;
    
    this.logger.info(`Validating exploit code for: ${exploitType}`);

    const validationPrompt = `Validate and analyze this exploit code:
    
    ${exploitCode}
    
    Provide:
    1. Code quality assessment
    2. Security and stealth analysis
    3. Effectiveness evaluation
    4. Potential improvements
    5. Risk assessment
    6. Detection likelihood
    
    Focus on practical effectiveness and security implications.`;

    const validation = await this.client.invoke(validationPrompt, null, true);

    return {
      exploitType,
      validation,
      codeAnalyzed: exploitCode ? true : false,
      timestamp: new Date().toISOString()
    };
  }

  async performGenericExploit(task) {
    this.logger.info(`Performing generic exploit task: ${task.name}`);
    
    const response = await this.callLLM(task);
    
    return {
      task: task.name,
      action: task.action,
      result: response,
      timestamp: new Date().toISOString()
    };
  }

  assessRiskLevel(exploitType) {
    const highRisk = ['rce', 'buffer', 'privesc', 'sqli'];
    const mediumRisk = ['xss', 'csrf', 'lfi', 'rfi'];
    const lowRisk = ['ssrf', 'xxe'];

    if (highRisk.includes(exploitType.toLowerCase())) return 'High';
    if (mediumRisk.includes(exploitType.toLowerCase())) return 'Medium';
    if (lowRisk.includes(exploitType.toLowerCase())) return 'Low';
    
    return 'Medium';
  }

  categorizeExploit(exploitType) {
    const categories = {
      'sqli': 'Injection',
      'xss': 'Client-Side',
      'rce': 'Code Execution',
      'lfi': 'File Inclusion',
      'rfi': 'File Inclusion',
      'csrf': 'Access Control',
      'xxe': 'XML Processing',
      'ssrf': 'Server-Side Request',
      'buffer': 'Memory Corruption',
      'privesc': 'Privilege Escalation'
    };

    return categories[exploitType.toLowerCase()] || 'General';
  }

  validateTask(task) {
    const baseValidation = super.validateTask(task);
    if (!baseValidation.valid) return baseValidation;

    const errors = [];
    
    // Exploit-specific validations
    if (task.action === 'exploit' && !task.parameters.type && !task.parameters.vulnerability) {
      errors.push('Exploit type or vulnerability is required');
    }

    if (task.action === 'payload' && !task.parameters.type) {
      errors.push('Payload type is required');
    }

    return {
      valid: errors.length === 0,
      errors: [...baseValidation.errors, ...errors]
    };
  }
}

// Signed by BillyC0der
